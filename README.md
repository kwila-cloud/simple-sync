# simple-sync
A simple sync system for local-first apps. 

Built with [Go](https://go.dev/), [Gin](https://github.com/gin-gonic/gin), [SQLite](https://www.sqlite.org/index.html), [JWT](https://jwt.io/), and [TOML](https://toml.io/en/). See the [Tech Stack](docs/tech-stack.md) document for details on the technologies used in this project and the rationale behind those choices.

**NOTE** - This project is in the alpha stage. Many of the things documented here and elsewhere in this repo do not actually exist yet.

## Quick Start

To run `simple-sync` using Docker Compose:

### Prerequisites
- Docker and Docker Compose installed
- Git (to clone the repository)

### Setup
1. Clone the repository:
   ```bash
   git clone https://github.com/kwila-cloud/simple-sync.git
   cd simple-sync
   ```

2. Create a `.env` file with your JWT secret:
   ```bash
   echo "JWT_SECRET=$(openssl rand -base64 32)" > .env
   ```
    **⚠️ REQUIRED:** JWT_SECRET is mandatory and must be at least 32 characters long - the application will exit with an error if not set or too short.

3. Start the services:
   ```bash
   docker compose up -d
   ```

4. Verify the service is running:
   ```bash
   curl http://localhost:8080/health
   ```
   You should see a JSON response with status "healthy".

### Optional: Add Frontend
To run with a frontend application, add it as an additional service in `docker-compose.yml`. For example:
```yaml
services:
  frontend:
    image: your-frontend-image
    ports:
      - "3000:3000"
    depends_on:
      - simple-sync
```

## Development

### Building

To build the application:

```bash
go build -o simple-sync ./src
```

This will make a `simple-sync` executable file.

### Running Locally

To run the application locally:

```bash
# Set JWT secret (required)
export JWT_SECRET="your-jwt-secret-here"

# Run the server
go run ./src

The server will start on port 8080 by default.

### Running Tests

To run the test suite:

Run unit, contract, and integration tests with race detection:
```bash
go test -race ./tests/unit ./tests/contract ./tests/integration
```

Run performance tests (without race detection):
```bash
go test ./tests/performance
```

This will run all tests including:
- **Contract tests** (`tests/contract/`) - API contract validation
- **Integration tests** (`tests/integration/`) - Full workflow testing
- **Unit tests** (`tests/unit/`) - Individual component testing
- **Performance tests** (`tests/performance/`) - Response time validation

## Events

Data is represented as a sequence of events.

Each event has the following schema of 6 fields, represented as a JSON object.

```json
{
  "uuid": "string",
  "timestamp": "uint64",
  "userUuid": "string",
  "itemUuid": "string",
  "action": "string",
  "payload": "string"
}
```

Event history is stored as a simple text file where each line is a JSON object representing an event.

All data querying is handled locally. This means that `simple-sync` is inappropriate for situations that require large numbers of items. It is much better suited for systems that need to store a small amount of items that don't change too frequently.

## Syncing Process

The syncing process ensures that all clients have the latest version of the event history. Here's a step-by-step breakdown:

1.  **Authoritative History:** The server maintains the authoritative history of all events. This is the single source of truth for the data.
2.  **Initial Sync:** When a new client comes online, it performs an initial sync by retrieving the entire authoritative history from the server via the [API](docs/api.md).
3.  **Local Diff History:** After the initial sync, the client keeps a local history (the "diff history") of any events generated by the user on that client. These events are stored locally and represent changes that have not yet been synchronized with the server.
4.  **Periodic Push:** The client periodically pushes its local diff history to the server via the [API](docs/api.md). This is typically triggered by the user (e.g., with a "sync" button) to avoid conflicts during active use.
5.  **Server-Side Merge:** The server receives the diff history from the client and merges it into the authoritative history, applying any necessary conflict resolution or validation logic. The server will also ensure that all events follow the rules defined in the [ACL Specification](docs/acl.md).
6.  **New Authoritative History:** The server responds to the client's push request with the updated authoritative history.
7.  **Client Update:** The client replaces its local copy of the authoritative history with the new version received from the server and clears its local diff history.

This process ensures that all clients eventually converge on the same state, while also allowing for offline work and local data access.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

